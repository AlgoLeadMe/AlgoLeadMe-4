n = int(input())
sk = [0,1,2,1] * (998)

for i in range(4,n+1):
    sk[i] = min(sk[i-3], sk[i-1]) + 1

if sk[n] % 2 :
    print('CY')
else:
    print('SK')

'''
풀이노트
 
3 또는 1 
SK start 무조건

1 - 1 = 0
    sk

2 - 1 -1 = 0 
   sk  cy 

3 -1 -1 -1 = 0 
  sk  cy sk 

3 -3 = 0 
  sk  

4 - 3 - 1 = 0 
최대한 많이.. ? 
4 - 1 - 1 - 1 - 1 = 0  
   sk  cy  sk  cy 

5 - 3 - 1 - 1 = 0 
    sk  cy  sk

5 - 1 - 3 - 1 = 0 
    sk  cy sk 

5 - 1 - 1 - 1 -1 -1 = 0  
    sk cy sk  cy  sk

6 - 3 - 1 - 1 - 1 = 0 
   sk  cy  sk  cy 

6 - 3 - 3 = 0 
   sk cy 

주어진 N이 짝수이면 무조건 상근이가 이긴다 ! 
그냥 최대한 많이 먹으면 된다 ? 

이걸 DP로 어떻게 접근 ???? 
3을 가져가는 경우와 1을 가져가는 경우를 비교해야 할 것 같은데 

아.. dp[n]에 값이 얼마나 있는지(가져간 횟수)를 보면 된다..! 

그리고 실행 횟수 (돌을 가져간 횟수) 가 짝수가 되면 창영이가 이긴다. -> 이 부분 판단 

'''